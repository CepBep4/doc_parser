import os
from state_manager import SystemState, logger
import pandas as pd
import yaml
from pathlib import Path
import json
import datetime

#Проверка pause.flag
def checkPause(state: SystemState) -> bool:
    if os.path.exists('logs/pause.flag'):
        state.pause = True
    return state.pause

#Загружаем csv
def load_csv(path: str) -> list[list]:
    try:
        df = pd.read_csv(path, skiprows=1, header=None, encoding="utf-8")
        if df.empty:
            raise ValueError("Пустой справочник")
        return df.values.tolist()
    except Exception as e:
        raise RuntimeError(f"Ошибка при загрузке CSV-файла: {e}")
    
#Загружаем yaml
def load_yaml(path: str) -> dict:
    try:
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)

        # if not isinstance(data, dict):
        #     raise BaseException("YAML-файл должен содержать словарь (dict) на верхнем уровне")

        return data

    except Exception as e:
        raise RuntimeError(f"Ошибка при загрузке YAML-файла: {e}")

#Проверка на повторную обработку
def checkAgainHandling(path: str) -> bool:
    log_path = "logs/process_log.json"

    if not os.path.exists(log_path):
        return False  # Логов нет — точно не обрабатывался

    with open(log_path, "r", encoding="utf-8") as f:
        try:
            js = json.loads(f.read())
        except json.JSONDecodeError:
            return False
    
    for j in js:
        if j["file"] == path:
            return True

    return False

#Записываем файл в при его несоответствии требованиям
def logNotProcessed(file_path, reason, ext, creditor, debtor):
    log_path = "logs/not_processed.json"

    entry = {
        "datetime": datetime.datetime.now().isoformat(),
        "file": file_path,
        "reason": reason
    }
    
    entry["ext"] = ext
    entry["creditor"] = creditor
    entry["debtor"] = debtor

    # Загрузка существующего массива или создание нового
    try:
        with open(log_path, "r", encoding="utf-8") as f:
            data = json.loads(f.read())
    except:
        data = []
        
    data.append(entry)

    # Перезапись всего массива
    with open(log_path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
        
#Ошибки в error_log.json
def logErrorJson(file_path, stage, error_msg):
    log_path = "logs/error_log.json"

    entry = {
        "datetime": datetime.datetime.now().isoformat(),
        "file": file_path,
        "stage": stage,
        "status": "error",
        "error_msg": error_msg
    }

    # Загрузка существующего массива или создание нового
    try:
        with open(log_path, "r", encoding="utf-8") as f:
            data = json.loads(f.read())
    except:
        data = []
        
    data.append(entry)

    # Перезапись всего массива
    with open(log_path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

#Проверка перед стартом
def checkSystemBeforeStart(state: SystemState):
    for directory in [True if os.path.exists(x) else x for x in ['configs','data','exports','logs']]:
        if directory != True:
            state.errors = f"Нарушена структура -> директория {directory} отсутсвует"
            breakWork(state)

#Проверяем структуру yaml файлов
def checkStructYaml(dictObject: dict, filename: str) -> str:
    if filename == "config":
        ...
        
    elif filename == "validators":
        if "date" in dictObject:
            if "regex" not in dictObject["date"] or "description" not in dictObject["date"]:
                raise BaseException
            
        if "number_ip" in dictObject:
            if "regex" not in dictObject["number_ip"] or "description" not in dictObject["number_ip"]:
                raise BaseException
            
        if "event" in dictObject:
            if "must_be_in" not in dictObject["event"] or "description" not in dictObject["event"]:
                raise BaseException
            
        if "adresat" in dictObject:
            if "must_be_in" not in dictObject["adresat"] or "description" not in dictObject["adresat"]:
                raise BaseException
            
    return dictObject
                

#Проверяем структуру csv файлов
def checkStructCsv(data: list[list], filename: str) -> dict:
    #Для форматс
    if filename == 'formats':
        if len(data[0]) == 3:
            response = {}
            for d in data:
                response[d[0]] = {
                    "description": d[1],
                    "parser":d[2]
                }
            return response
        else:
            raise BaseException("Нарушена структура")
    
    #Для адресатов
    elif filename == "adresat" or filename == "events":
        if len(data[0]) == 3:
            response = []
            for d in data:
                response.append(list(d))
            return response
        else:
            raise BaseException("Нарушена структура")  
          
    elif filename == "responsible":
        if len(data[0]) == 4:
            response = []
            for d in data:
                response.append({
                    "name": d[0],
                    "surname":d[1],
                    "patronymic":d[2],
                    "position":d[3],
                })
            return response
        else:
            raise BaseException("Нарушена структура") 
             
    elif filename == "creditors_to_process":
        if len(data[0]) == 4:
            response = {}
            for d in data:
                response[d[0]] = {
                    "link":d[1],
                    "status":d[2],
                    "comments":d[3],
                }
            return response
        else:
            raise BaseException("Нарушена структура")      

#Поиск пути
def findPathFromPattern(rawPath: str) -> str:
    try:
        path = Path(rawPath).expanduser().resolve(strict=False)
        if not path.exists():
            raise FileNotFoundError(f"Путь не существует: {rawPath}")
        return path.as_posix()
    except Exception as e:
        raise RuntimeError(f"Ошибка при обработке пути '{rawPath}': {e}")

#Завершаем работу
def breakWork(state: SystemState):
    #Действия перед завершением
    print(f"\n")
    if state.errors:
        logger.critical(f"Ошибки: {state.errors}")
    if state.pause:
        logger.info(f"Ручная остановка: {state.pause}")
    logger.info(f"Работа програмы завершена, время работы: {round(state.workTime, 3)}сек\nВремя работы по процессам\n"+"\n".join([f'Процесс |{x["name_process"]}| время: {round(x["time_process"], 3)}сек' for x in state.journalProcess]))
    
    #Завершаем работу
    exit()
    
#Проверяем направление файла
def getDirection(p, config) -> str:
    """
    Определяет направление файла на основе содержимого и конфигурации.
    
    Args:
        p: Объект HandlingProcess с текстом и метаданными файла
        config: Конфигурация с правилами определения направления
        
    Returns:
        "inbound" - входящий документ
        "outbound" - исходящий документ
    """
    import re
    
    # Получаем текст файла
    file_text = p.text or ""
    
    # Компилируем регексы для явных ключевых слов
    explicit_patterns = config.validators.get('direction_detection', {}).get('explicit_keywords', {
        'outbound': [r'исходящ(ее|ий|ая)', r'outgoing', r'outbound'],
        'inbound': [r'входящ(ее|ий|ая)', r'incoming', r'inbound']
    })
    
    # Проверяем явные метки направления в тексте (приоритет)
    for direction, patterns in explicit_patterns.items():
        for pattern in patterns:
            if re.search(pattern, file_text, re.IGNORECASE):
                return direction
    
    # Получаем паттерны для входящих документов из barcode секции
    inbound_patterns = config.validators.get('barcode', {}).get('regex_any', [
        r'^\s*\d(?:[\s\d]{6,})/\s*\d{2,}\s*$',      # штрихкод ФССП
        r'Идентификатор ИП:\s*\d+',                    # идентификатор ИП
        r'Вид документа:\s*[A-Z0-9_,-]+'              # служебная метка
    ])
    
    # Проверяем признаки входящего документа по содержимому
    for pattern in inbound_patterns:
        if re.search(pattern, file_text, re.IGNORECASE):
            return "inbound"
    
    # Фолбэк по пути/имени файла
    low_path = f"{p.path}/{p.exportName}".lower()
    
    # Проверяем ключевые слова в пути/имени
    if any(keyword in low_path for keyword in ["исходящ", "/out", "\\out"]) or p.exportName.lower().startswith("исх"):
        return "outbound"
    
    if any(keyword in low_path for keyword in ["входящ", "/in", "\\in"]) or p.exportName.lower().startswith("вх"):
        return "inbound"
    
    # Возвращаем направление по умолчанию из конфига
    default_direction = config.validators.get('direction_detection', {}).get('default_direction', 'outbound')
    return default_direction

#Создаём промпт 
def build_structured_prompt(text: str, direction: str) -> str:
    """
    Создает структурированный промпт для ИИ в зависимости от направления документа.
    
    Args:
        text: Текст документа для анализа
        direction: Направление документа ("inbound" или "outbound")
        
    Returns:
        str: Готовый промпт для отправки в ИИ
    """
    
    # Промпт для входящих документов (постановления, акты, уведомления ФССП)
    INBOUND_PROMPT = """Возьми роль юриста с 10 летним стажем, который знает и умеет интерпретировать все документы по исполнительному производству и понимает их смысл.

Твоя миссия правильно интерпретировать документ и заполнить все поля.

Аспект 1
- Определи "№ ИД" — это номер исполнительного производства, указанный в документе.
  Обычно он располагается во вводной части, сразу после слов "Исполнительное производство:".
  Формат: несколько чисел, разделённых косой чертой "/", и в конце буквенный суффикс (например: "-ИП").
  Важно: учитывать также номера с опечатками или иными суффиксами ("-ОЖ", "-ИС", "-ДС" и т.п.),
  так как это всё равно относится к исполнительным производствам.
  Если в документе встречаются другие номера (судебных дел, исполнительных листов, договоров),
  их не учитывать — фиксируй только номера, имеющие формат "числа/числа/числа-буквы".

- Определи "Дата" — это календарная дата составления самого документа.
  Правила:
  1. Дата должна идти после названия документа/мероприятия (например: "Постановление", "Уведомление", "Определение").
  2. Для входящих документов дата указывается в шапке или сразу после названия документа.
  3. Игнорируй все другие даты (даты возбуждения ИП, судебных актов, исполнительных листов, заявлений и др.).
  4. Формат даты всегда ДД.ММ.ГГГГ.

- Определи "Мероприятие" — для входящих документов всегда указывай строку "Получен документ".

- Определи "Адресат мероприятия" — это организация или орган, КОМУ направлен документ
  или кто указан в "шапке" документа как получатель (например: ОСП, ФССП, банк,
  налоговая, Росреестр, ГИБДД, и др.).

- Определи "Адрес мероприятия" — это почтовый или юридический адрес органа или организации,
  куда направляется заявление/ходатайство (например: адрес ОСП, инспекции ФНС, Росреестра, банка)

- Определи "Тип мероприятия" — значение этого поля всегда равно значению поля "Мероприятие", без изменений и сокращений.

- Определи "Цель мероприятия" — это пояснение, зачем нужно выполнить мероприятие.
  1. Для входящих документов (постановления, акты, уведомления) — это название процессуального акта
     ("Постановление", "Акт", "Уведомление", "Определение").
  2. Не путай "Цель мероприятия" с "Мероприятием": Цель мероприятия отвечает на вопрос "что за документ/акт?",
     цель — "зачем он издан/чего хотят достичь".

Аспект 2
- Сформируй "Комментарий" — это краткая юридическая характеристика документа.
  Правила:
  1. Укажи, какой это документ (заявление, постановление, ходатайство и т.п.).
  2. Опиши его основную суть: какое действие требуется или какое решение принято.
  3. Укажи правовую цель документа: взыскание, арест, запрос, ограничение и т.д.
  4. Комментарий должен быть лаконичным (2–3 предложения), юридически точным,
     без пересказа всего текста.

- Определи "Ответственный" — это лицо, которое подписало документ.
  1. Если документ входящий (постановление, акт, решение ФССП) — укажи судебного пристава
     или должностное лицо ФССП, указанное в шапке или под подписью (например: "Степченко Л. А.").
  2. В результате всегда возвращай фамилию и инициалы.

Текст документа: {text}

Требования к представлению данных: Формат вывода данных должен строго соответствовать следующей структуре, при этом все данные должны быть получены непосредственно из текста документа:

{{
  "Дата": "28.08.2024",
  "Мероприятие": "Получен документ",
  "№ ИД": "113643/24/59023-ИП",
  "Адресат мероприятия": "ОСП",
  "Адрес мероприятия": "618590, Россия, Пермский край, Красновишерский р-н, г. Красновишерск, ул. Куйбышева, д. 10",
  "Тип мероприятия": "Постановление",
  "Цель мероприятия": "Установление места фактического проживания должника и выявление имущества",
  "Комментарий о типе": null,
  "Комментарий": "Заявление взыскателя о направлении запросов в органы и организации для установления адреса проживания должника и наличия имущества.",
  "Ответственный": "Пендюкова В. С.",
  "Файл": "20250820_113643-24-59023-ИП_001.doc",
  "Оригинал": "C:/data/ip/113643-24-59023-ИП/заявление_запросы.doc",
  "Обработано": "2025-08-20T15:50:00",
  "Status": "ok"
}}

Запреты и пояснения:
1. Не выдумывай данные — заполняй только те поля, которые прямо указаны в документе.
2. Если данные отсутствуют, возвращай null (или не включай поле, если оно необязательное).
3. Не используй данные из внешнего контекста или догадок — только из текста документа.
4. "Ответственный" всегда должен быть только лицо, подписавшее документ:
   - во входящих — судебный пристав или должностное лицо ФССП.
5. Формат даты всегда указывай в виде ДД.ММ.ГГГГ (например: "28.08.2024").
6. В "Комментарий" не вставляй прямые цитаты из текста, а формулируй юридически точное резюме.
7. Структура JSON должна строго соблюдаться: порядок ключей, регистр, формат.
8. В поле "Status" всегда указывай "ok", если обработка прошла успешно.
9. В "Комментарий о типе" по умолчанию возвращай null (резерв для будущего анализа)."""

    # Промпт для исходящих документов (заявления, ходатайства, обращения)
    OUTBOUND_PROMPT = """Возьми роль юриста с 10 летним стажем, который знает и умеет интерпретировать все документы по исполнительному производству и понимает их смысл.

Твоя миссия правильно интерпретировать документ и заполнить все поля.

Аспект 1
- Определи "№ ИД" — это номер исполнительного производства, указанный в документе.
  Обычно он располагается во вводной части, сразу после слов "Исполнительное производство:".
  Формат: несколько чисел, разделённых косой чертой "/", и в конце буквенный суффикс (например: "-ИП").
  Важно: учитывать также номера с опечатками или иными суффиксами ("-ОЖ", "-ИС", "-ДС" и т.п.),
  так как это всё равно относится к исполнительным производствам.
  Если в документе встречаются другие номера (судебных дел, исполнительных листов, договоров),
  их не учитывать — фиксируй только номера, имеющие формат "числа/числа/числа-буквы".

- Определи "Дата" — это календарная дата составления самого документа.
  Правила:
  1. Дата должна идти после названия документа/мероприятия (например: "Постановление", "Уведомление", "Определение").
  2. Для исходящих документов дата указывается внизу перед подписью.
  3. Игнорируй все другие даты (даты возбуждения ИП, судебных актов, исполнительных листов, заявлений и др.).
  4. Формат даты всегда ДД.ММ.ГГГГ.

- Определи "Мероприятие" — для исходящих документов всегда указывай строку "Заявление".

- Определи "Адресат мероприятия" — это организация или орган, КОМУ направлен документ
  или кто указан в "шапке" документа как получатель (например: ОСП, ФССП, банк,
  налоговая, Росреестр, ГИБДД, и др.).

- Определи "Адрес мероприятия" — это почтовый или юридический адрес органа или организации,
  куда направляется заявление/ходатайство (например: адрес ОСП, инспекции ФНС, Росреестра, банка)

- Определи "Тип мероприятия" — значение этого поля всегда равно значению поля "Мероприятие", без изменений и сокращений.

- Определи "Цель мероприятия" — это пояснение, зачем нужно выполнить мероприятие.
  1. Для исходящих документов (заявления, ходатайства, обращения) — это всегда "Заявление" или "Ходатайство".
     Конкретное действие (например: "направить запрос") отражается в "Цель мероприятия".
  2. Не путай "Цель мероприятия" с "Мероприятием": Цель мероприятия отвечает на вопрос "что за документ/акт?",
     цель — "зачем он издан/чего хотят достичь".

Аспект 2
- Сформируй "Комментарий" — это краткая юридическая характеристика документа.
  Правила:
  1. Укажи, какой это документ (заявление, постановление, ходатайство и т.п.).
  2. Опиши его основную суть: какое действие требуется или какое решение принято.
  3. Укажи правовую цель документа: взыскание, арест, запрос, ограничение и т.д.
  4. Комментарий должен быть лаконичным (2–3 предложения), юридически точным,
     без пересказа всего текста.

- Определи "Ответственный" — это лицо, которое подписало документ.
  1. Если документ исходящий (заявление, ходатайство, обращение) — укажи нашего сотрудника
     или представителя взыскателя, чья фамилия и инициалы стоят в подписи (например: "Пендюкова В. С.").
  2. В результате всегда возвращай фамилию и инициалы.

Текст документа: {text}

Требования к представлению данных: Формат вывода данных должен строго соответствовать следующей структуре, при этом все данные должны быть получены непосредственно из текста документа:

{{
  "Серия ИП": "113643/24/59023-ИП",
  "Дата": "28.08.2024",
  "Мероприятие": "Заявление",
  "№ ИД": "113643/24/59023-ИП",
  "Адресат мероприятия": "ОСП",
  "Адрес мероприятия": "618590, Россия, Пермский край, Красновишерский р-н, г. Красновишерск, ул. Куйбышева, д. 10",
  "Тип мероприятия": "Заявление",
  "Цель мероприятия": "Установление места фактического проживания должника и выявления имущества",
  "Комментарий о типе": null,
  "Комментарий": "Заявление взыскателя о направлении запросов в органы и организации для установления адреса проживания должника и наличия имущества.",
  "Ответственный": "Пендюкова В. С.",
  "Файл": "20250820_113643-24-59023-ИП_001.doc",
  "Оригинал": "C:/data/ip/113643-24-59023-ИП/заявление_запросы.doc",
  "Обработано": "2025-08-20T15:50:00",
  "Status": "ok"
}}

Запреты и пояснения:
1. Не выдумывай данные — заполняй только те поля, которые прямо указаны в документе.
2. Если данные отсутствуют, возвращай null (или не включай поле, если оно необязательное).
3. Не используй данные из внешнего контекста или догадок — только из текста документа.
4. Не путай "Мероприятие" с названием документа (например, "Заявление" не является мероприятием,
   если в тексте указано "Прошу направить запрос").
5. Не путай "Цель мероприятия" с "Мероприятием": цель отвечает на вопрос "зачем?",
   мероприятие — "что сделать?".
6. "Ответственный" всегда должен быть только лицо, подписавшее документ:
   - в исходящих документах — наш сотрудник/представитель взыскателя.
   Представителей сторон (Пендюкова, Аникина и др.) указывать только в исходящих документах.
7. Формат даты всегда указывай в виде ДД.ММ.ГГГГ (например: "28.08.2024").
8. Если в документе несколько мероприятий, указывай их все через запятую,
   но цель мероприятия пиши отдельно по каждому действию, если это возможно.
9. В "Комментарий" не вставляй прямые цитаты из текста, а формулируй юридически точное резюме.
10. Структура JSON должна строго соблюдаться: порядок ключей, регистр, формат.
11. В поле "Status" всегда указывай "ok", если обработка прошла успешно.
12. В "Комментарий о типе" по умолчанию возвращай null (резерв для будущего анализа)."""

    # Выбираем промпт по направлению
    if direction == "inbound":
        return INBOUND_PROMPT.format(text=text)
    elif direction == "outbound":
        return OUTBOUND_PROMPT.format(text=text)
    else:
        # По умолчанию используем исходящий промпт
        return OUTBOUND_PROMPT.format(text=text)
    